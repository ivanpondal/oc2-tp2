\subsection{Blur Gaussiano}

\subsubsection{Descripción del filtro}

El filtro \textit{Blur Gaussiano}, produce un desenfoque en la imagen original
en base a un coeficiente $\sigma$ y \textit{r} entero. Estas variables son
parámetros que afectan por un lado, la dispersión o varianza de la distribución
normal de Gauss, y por el otro, la discretización de la misma. El uso de la
función de densidad de la distribución normal es clave para el resultado del
efecto ya que el mismo es el resultado de realizar un promedio ponderado de
los vecinos de cada pixel, tomando como pesos los valores discretizados de la
función.

Esto tiene una consecuencia directa sobre el resultado del filtro, y es que si
tomamos un $\sigma$ grande, implicando mayor dispersión, y utilizamos un
\textit{r} pequeño, veremos que la imagen producida se verá oscurecida (Figura \ref{fig:blur_s1_r1}), esto
se debe a que nuestra función de densidad integra a 1 cuando se recorren todos
sus valores, pero al discretizar, la suma no llega a 1, se está recortando gran
parte de la imagen de la función. Una posible solución es aumentar el radio,
obteniendo así más valores de la función y permitiendo que la suma vaya
aproximándose a 1 (Figura \ref{fig:blur_s1_r5}).

% TODO: generar las imágenes posta, esto es fruta

\begin{figure}[H]
	\centering
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=\linewidth]{blur_original.jpg}
		\caption{Imagen original}
		\label{fig:blur_original}
	\end{minipage}\hfill
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=\linewidth]{blur_s1_r1.jpg}
		\caption{Blur  $\sigma = 1, r = 1$}
		\label{fig:blur_s1_r1}
	\end{minipage}\hfill
	\begin{minipage}{.3\textwidth}
		\centering
		\includegraphics[width=\linewidth]{blur_s1_r5.jpg}
		\caption{Blur $\sigma = 1, r = 5$}
		\label{fig:blur_s1_r5}
	\end{minipage}
\end{figure}


A continuación se describirán las dos implementaciones que se realizaron en ASM
para lo cual antes comentaremos los principales componentes que aparecen
en las mismas. Por un lado tenemos las imágenes de entrada y la de salida, donde
comienzan siendo idénticas, y a medida que avanza el algoritmo, la de destino va
modificándose hasta llegar al resultado final. Por otra parte está la matriz de
convolución. Esta es de gran importancia, ya que es la que contiene todos los
coeficientes discretizados de la función de Gauss, y será la que al aplicarse
sobre los vecinos del pixel a procesar nos generará el promedio ponderado.

\subsubsection{Implementación de control}

Aquí desarrollaremos en detalle sobre la primer implementación en ASM, la de
control, cuya característica principal es mediante SIMD procesar de a pixeles
enteros las operaciones necesarias.

\subsubsection{Implementación experimental}

\subsection{Estudio sobre la relación entre la representación numérica escogida y los tiempos de ejecución}

\subsubsection{Introducción}

Al analizar nuestra implementación del blur gaussiano en busca de una posible mejora o variante que pueda resultar de interes surgio la idea de cambiar el sistema de representación numerica que se utilizaba, la versión base utiliza double lo cual asegura una buena precisión al hacer los cálculos, pero muchas veces esta precisión no es necesaria y se prefiere una performance mayor en terminos de tiempos de ejecución a partir de esto surge la idea de nuestro experimento.

\subsubsection{Hipotesis del Experimento}

A partir de las ideas mencionadas surge entonces un experimento para intentar corroborar esta intuición acerca de como al sacrificar precisión podemos quizas obtener un filtro de mayor velocidad. Creemos que si trabajamos con floats y necesitamos para ellos 32 bits, entonces, al pasar nuestra implementación a 16 bits utilizando unsigned short podremos acercarnos a una disminución en el tiempo de ejecución de la mitad. Esta idea se fundamenta a partir de como gracias a las instrucciones que assembler posee para operar con multiples paquetes de datos (SIMD) podemos trabajar con el doble de paquetes si son de la mitad de tamaño que antes. Un punto importante con el que tuvimos que enfrentarnos fue como adaptar el algoritmo para hacer perder la menor cantidad de precisión posible. Para esto antes armamos una variante del kernel que en vez de trabajar con numeros entre 0 y 1 trabajaba con numeros entre 0 y 255, valores con los que unsigned short puede manejarse bien, una mejor explicación de la implementación de este algoritmo esta en la sección de Descripción del codigo en el informe.

\subsubsection{Metodos utilizados}

Para corroborar nuestra hipotesis generamos un conjunto de imagenes cuadradas con pixels de colores seleccionados de forma aleatoria, para hacer esto creamos el archivo llamado random\_images\_generayor.py el cual tiene instrucciones de uso detalladas en sus comentarios, de todas maneras el funcionamiento de nuestro blur gaussiano no depende del color de los pixels por lo que se podria haber utilizado cualquier conjunto de imagenes no necesariamente aleatorias. A partir de esto creamos imagenes de 5 tamaños distintos, que iban de 25x25 hasta 400x400. Luego repitiendo los experimentos de forma suficiente como para disminuir la varianza al máximo. Una vez obtenidos estos resultados analizamos que tanto bajo la calidad de la imagen para esto nos guiamos primero de la mera observación y complementandolo con el análisis que bmpdiff nos brinda.

Para los experimentos utilizamos tres implementaciones distintas de blur hechas en assembler estas son explicadas con detalle en la sección de descripción del codigo.

\subsubsection{Verificación: Experimento 1}


\begin{figure}[H]
\centering
    \includegraphics[scale=0.5]{imgs/blur_ushort.jpg} 
  \caption{\footnotesize{Grafico donde se observan los tiempo de ejecución de las dos implementaciones estudiadas funcionando con distintos tamaños de imagenes.}}
  \label{fig:tiempo2}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\textwidth}
  \centering
    \includegraphics[width=1\textwidth]{imgs/chip_hd_v1.jpg}
  \caption{\footnotesize{Imagen filtrada con blur\_asm\_v1 ($\sigma$ = 3 $r$ = 9), no presenta problemas para mantener el brillo de la imagen.}}
  \label{fig:tiempo1}
\end{minipage}%
\hspace{0.03\textwidth}
\begin{minipage}{0.48\textwidth}   
  \centering
    \includegraphics[width=1\textwidth]{imgs/chip_hd_ushort.jpg} 
  \caption{\footnotesize{Imagen filtrada con blur\_asm\_ushort ($\sigma$ = 3 $r$ = 9), la versión que utiliza unsigned short, se nota el oscurecimiento ocasionado probablemente por la perdida de precisión en los cálculos.}}
  \label{fig:tiempo2}
\end{minipage}
\end{figure}


\subsubsection{Verificación: Experimento 2}

Si bien el resultado anterior fue muy prometedor, ya que este mostraba resultados bastante concluyentes sobre como el tiempo de ejecución habia casi disminuido a la mitad, de todas maneras notamos que la utilización de unsigned int en la nueva implementación habia tenido ciertos cambios ajenos al tamaño de la estructura del dato que podian llegar a contribuir en la velocidad de computo. La principal sospecha surgió de las instrucciones de conversión de punto flotante a int (y de int a punto flotante), estas aparecen en blur\_asm\_v1 pero dejan de ser necesarias en blur\_asm\_ushort.

Para verificar que la influencia de estas instrucciones no era tan grande implementamos blur\_asm\_uint, esta variante de blur, utiliza unsigned int por lo que siempre nos mantenemos en representaciones de punto fijo evitando conversiones. La gran diferencia con la implementación que utiliza shorts es que el tamaño requerido para hacer los cálculos no va a ser distinto del necesario en la implementacion base, blur\_asm\_v1. 

Los resultados fueron sorpresivos, la influencia de las instrucciones de conversion parecio casi nula en la velocidad de computa de los programas. Esto se puede observar en los siguientes gráficos.

\begin{figure}[H]
\centering
    \includegraphics[scale=0.5]{imgs/blur_uint.jpg}
  \caption{\footnotesize{Grafico donde se observan los tiempos de ejecución de las dos implementaciones estudiadas funcionando con distintos tamaños de imagenes.}}
  \label{fig:tiempo1}
\end{figure}

Otro detalle relevante es que observamos como en este caso no se perdia brillo como pasaba con la implementación de blur UInt, se nota como la mayor cantidad de bits permiten una precisión suficiente para no redondear tanto los numeros para abajo y evitando acercarnos a valores cercanos a 0 en la paleta de colores.

\begin{figure}[H]
\centering
    \includegraphics[scale=0.5]{imgs/chip_hd_uint.jpg}
  \caption{\footnotesize{Imagen filtrada con el blur\_asm\_uint, valores utilizados $\sigma$ = 3 $r$ = 9}}
  \label{fig:tiempo1}
\end{figure}
